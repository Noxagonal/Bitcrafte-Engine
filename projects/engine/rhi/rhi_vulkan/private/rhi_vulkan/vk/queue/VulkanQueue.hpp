#pragma once

#include <build_configuration/BuildConfigurationComponent.hpp>
#include <core/containers/List.hpp>
#include <core/containers/Pair.hpp>

#include <vulkan/vulkan.h>
#include <mutex>



namespace bc {
namespace rhi {



class VulkanDevice;
class DeviceQueueResolver;



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct SubmitInfo
{
	List<VkCommandBuffer>										command_buffers;
	List<Pair<VkSemaphore, VkPipelineStageFlags>>				wait_semaphores;
	List<VkSemaphore>											signal_semaphores;
};



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct SwapchainPresentInfo
{
	VkSwapchainKHR												swapchain;
	u32													image_index;
};



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class VulkanQueue
{
	friend class DeviceQueueResolver;

public:

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void														Submit(
		const List<VkCommandBuffer>							&	command_buffers,
		const List<Pair<VkSemaphore, VkPipelineStageFlags>>	&	wait_semaphores					= {},
		const List<VkSemaphore>								&	signal_semaphores				= {},
		VkFence													fence							= VK_NULL_HANDLE
	);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void														Submit(
		const List<SubmitInfo>								&	submit_infos,
		VkFence													fence							= VK_NULL_HANDLE
	);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void														Present(
		const List<VkSemaphore>								&	wait_semaphores,
		const List<SwapchainPresentInfo>					&	swapchains
	);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	VkQueue														GetQueue() const;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	u32													GetQueueFamilyIndex() const;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	VkBool32													SupportsPresentation() const;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	const VkQueueFamilyProperties							&	GetQueueFamilyProperties() const;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	u32													GetBasedOn() const;

private:

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	std::shared_ptr<std::mutex>									queue_mutex;						///< Mutex for queue submissions, only one thread must submit work at a time for single queue.
	VkQueue														queue						= {};	///< VkQueue handle.
	u32													queue_family_index			= {};	///< Index of the queue family.
	VkBool32													supports_presentation		= {};	///< VK_TRUE if you can present using this queue, VK_FALSE if you can not.
	VkQueueFamilyProperties										queue_family_properties		= {};	///< Typical VkQueueFamilyProperties.
	u32													based_on					= {};	///< Which other queue this one is based off.
};



} // rhi
} // bc
