#pragma once

#include <build_configuration/BuildConfigurationComponent.hpp>
#include <core/memory/HeapMemoryBlock.hpp>

#include <core/data_types/FundamentalTypes.hpp>
#include <core/utility/concepts/TypeTraitConcepts.hpp>



namespace bc {
namespace memory {



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief
/// A buffer for POD types which automatically expands when needed.
///
/// This is meant to be a simple temporary container for POD types.
///
/// @tparam Type
/// The type of the elements in the buffer.
template<utility::POD Type>
class PODAutoBuffer
{
public:

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	PODAutoBuffer() = default;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	PODAutoBuffer( i64 initial_size )
	{
		Resize( initial_size );
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	PODAutoBuffer( const PODAutoBuffer& other )
	{
		Copy( other );
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	PODAutoBuffer( PODAutoBuffer&& other )
	{
		Swap( other );
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	~PODAutoBuffer()
	{
		Clear();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	auto operator=( const PODAutoBuffer& other ) -> PODAutoBuffer&
	{
		Copy( other );
		return *this;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	auto operator=( PODAutoBuffer&& other ) -> PODAutoBuffer&
	{
		Swap( other );
		return *this;
	}

	auto operator=( std::nullptr_t ) -> PODAutoBuffer&
	{
		Clear();
		return *this;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	auto operator[]( i64 index ) -> Type&
	{
		return *Get( index );
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	auto operator[]( i64 index ) const -> const Type&
	{
		return *Get( index );
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	[[nodiscard]]
	auto Get( i64 index ) -> Type*
	{
		if( index >= heap_block.count ) Resize( index * 2 );
		return &heap_block.data[ index ];
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	[[nodiscard]]
	auto Get( i64 index ) const -> const Type*
	{
		if( index >= heap_block.count ) Resize( index * 2 );
		return &heap_block.data[ index ];
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	[[nodiscard]]
	auto Data() const -> const Type* { return heap_block.data; }

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	[[nodiscard]]
	auto Data() -> Type* { return heap_block.data; }

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	[[nodiscard]]
	auto Size() const -> i64 { return heap_block.count; }

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void FillRange( i64 begin, i64 length, const Type& value )
	{
		if( length <= 0 ) return;
		if( begin < 0 ) begin = 0;

		auto end = begin + length;
		if( end >= heap_block.count ) Resize( end * 2 );

		for( i64 i = begin; i < end; ++i )
		{
			heap_block.data[ i ] = value;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void Resize( i64 new_size )
	{
		if( !heap_block.data )
		{
			if( new_size <= 0 ) return;
			heap_block.Allocate( new_size, alignof( Type ) );
			return;
		}

		if( new_size <= 0 )
		{
			heap_block.Clear();
			return;
		}

		heap_block.Reallocate( new_size, alignof( Type ) );
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void Clear() { Resize( 0 ); }

private:

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void Copy( const PODAutoBuffer& other )
	{
		heap_block.Allocate( other.heap_block.count, alignof( Type ) );

		for( i64 i = 0; i < heap_block.count; ++i )
		{
			heap_block.data[ i ] = other.heap_block.data[ i ];
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void Swap( PODAutoBuffer& other )
	{
		std::swap( heap_block, other.heap_block );
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	HeapMemoryBlock<Type> heap_block = {};
};



} // namespace memory
} // namespace bc
