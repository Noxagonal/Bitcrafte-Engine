#pragma once

#include "StackTraceFrame.hpp"
#include <core/memory/HeapMemoryBlock.hpp>



namespace bc {
namespace diagnostic {



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class BITCRAFTE_ENGINE_API StackTrace
{
public:

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	StackTrace() noexcept = default;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	StackTrace( const StackTrace& other ) noexcept;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	StackTrace( StackTrace&& other ) noexcept = default;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	~StackTrace() noexcept;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	auto operator=( const StackTrace& other ) noexcept -> StackTrace&;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	auto operator=( StackTrace&& other ) noexcept -> StackTrace& = default;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// @brief
	/// Gets the stack trace to where this function was called.
	///
	/// @param leaf_calls_to_ignore
	/// How many functions to skip from the stack trace, this is useful when we want to ignore helper functions and other locations
	/// that are always part of the stack trace. By default, calling this function already skips the trace inside this function,
	/// value of 1 will skip including the trace to the function that called this function and so on.
	///
	/// @return
	/// New stack trace to this location.
	static auto Current( i64 leaf_calls_to_ignore = 0 ) noexcept -> StackTrace;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void Clear() noexcept;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	auto IsEmpty() const noexcept -> bool;

private:

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void Copy( const StackTrace& other ) noexcept;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void Swap( StackTrace& other ) noexcept;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void CopyConstructStackTraceFrame( i64 at_index, const StackTraceFrame& other ) noexcept;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void MoveConstructStackTraceFrame( i64 at_index, StackTraceFrame&& other ) noexcept;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void DestructStackTraceFrame( i64 at_index ) noexcept;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void DestructAllStackTraceFrames() noexcept;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	i64											frame_count		= 0;
	memory::HeapMemoryBlock<StackTraceFrame>	frame_list;
};



} // diagnostic
} // bc
