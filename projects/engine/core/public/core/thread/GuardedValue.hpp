#pragma once

#include <build_configuration/BuildConfigurationComponent.hpp>

#include <mutex>



namespace bc {
namespace thread {



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief
/// Ensures that a value is always protected by a mutex when trying to access it.
///
/// For example:<br>
///		// When creating:
///		auto guarded_value = GuardedValue<int>();
///		// When accessing the value:
///		guarded_value( []( int & value ){ /* Do stuff with value */ } );
///
/// @tparam T
/// Type of the value we are guarding.
template<typename T>
class GuardedValue
{
public:

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	GuardedValue() = default;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	GuardedValue( const GuardedValue& other ) = delete;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	GuardedValue( GuardedValue&& other ) = delete;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	GuardedValue( const T& initial_value )
	:
		value( initial_value )
	{}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename FuncT>
	void operator()( FuncT && function )
	{
		auto lock_guard = std::lock_guard( mutex );

		function( value );
	}

private:

	T			value;
	std::mutex	mutex;
};



} // code_inspector
} // bc
